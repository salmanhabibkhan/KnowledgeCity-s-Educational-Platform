import * as autoscaling from 'aws-cdk-lib/aws-autoscaling';
import * as ec2 from "aws-cdk-lib/aws-ec2";
import * as eks from "@aws-cdk/aws-eks-v2-alpha";
import * as eksv1 from 'aws-cdk-lib/aws-eks';
import { IKey } from "aws-cdk-lib/aws-kms";
import { ILayerVersion } from "aws-cdk-lib/aws-lambda";
import { Construct } from "constructs";
import { ClusterInfo, ClusterProvider } from "../spi";
import * as utils from "../utils";
import { AutoscalingNodeGroup, ManagedNodeGroup } from "./types";
import { NodePoolV1Spec } from "../addons/karpenter/types";
export declare function clusterBuilderv2(): ClusterBuilderV2;
export interface ComputeConfig extends eks.ComputeConfig {
    /**
     * Extra node pools to be added to the Auto Mode Cluster
     */
    extraNodePools?: {
        [key: string]: NodePoolV1Spec;
    };
}
/**
 * Properties for the generic cluster provider, containing definitions of managed node groups,
 * auto-scaling groups, fargate profiles.
 */
export interface GenericClusterProviderV2Props extends Partial<eks.ClusterProps> {
    /**
     * Whether cluster has internet access.
     */
    isolatedCluster?: boolean;
    /**
     * Whether API server is private.
     */
    privateCluster?: boolean;
    /**
     * Array of managed node groups.
     */
    managedNodeGroups?: ManagedNodeGroup[];
    /**
     * Array of autoscaling node groups.
     */
    autoscalingNodeGroups?: AutoscalingNodeGroup[];
    /**
     * EKS Automode compute config
     */
    compute?: ComputeConfig;
    /**
     * Fargate profiles
     */
    fargateProfiles?: {
        [key: string]: eks.FargateProfileOptions;
    };
    /**
     * Tags for the cluster
     */
    tags?: {
        [key: string]: string;
    };
}
export declare class ComputeConfigConstraints implements utils.ConstraintsType<ComputeConfig> {
    nodePools: utils.ArrayConstraint;
}
export declare class GenericClusterPropsV2Constraints implements utils.ConstraintsType<GenericClusterProviderV2Props> {
    /**
    * managedNodeGroups per cluster have a soft limit of 30 managed node groups per EKS cluster, and as little as 0. But we multiply that
    * by a factor of 5 to 150 in case of situations of a hard limit request being accepted, and as a result the limit would be raised.
    * https://docs.aws.amazon.com/eks/latest/userguide/service-quotas.html
    */
    managedNodeGroups: utils.ArrayConstraint;
    /**
    * autoscalingNodeGroups per cluster have a soft limit of 500 autoscaling node groups per EKS cluster, and as little as 0. But we multiply that
    * by a factor of 5 to 2500 in case of situations of a hard limit request being accepted, and as a result the limit would be raised.
    * https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-quotas.html
    */
    autoscalingNodeGroups: utils.ArrayConstraint;
}
export declare const defaultOptionsv2: {};
export declare class ClusterBuilderV2 {
    private props;
    private privateCluster;
    private managedNodeGroups;
    private autoscalingNodeGroups;
    private compute;
    private fargateProfiles;
    constructor();
    withCommonOptions(options: Partial<eks.ClusterProps>): this;
    managedNodeGroup(...nodeGroups: ManagedNodeGroup[]): this;
    autoscalingGroup(...nodeGroups: AutoscalingNodeGroup[]): this;
    computeConfig(config: ComputeConfig): this;
    fargateProfile(name: string, options: eks.FargateProfileOptions): this;
    version(version: eks.KubernetesVersion): this;
    build(): GenericClusterProviderV2;
}
/**
 * Cluster provider implementation that supports multiple node groups.
 */
export declare class GenericClusterProviderV2 implements ClusterProvider {
    readonly props: GenericClusterProviderV2Props;
    constructor(props: GenericClusterProviderV2Props);
    /**
     * @override
     */
    createCluster(scope: Construct, vpc: ec2.IVpc, secretsEncryptionKey?: IKey, kubernetesVersion?: eks.KubernetesVersion, clusterLogging?: eks.ClusterLoggingTypes[], ipFamily?: eks.IpFamily): ClusterInfo;
    /**
     * Template method that may be overridden by subclasses to create a specific cluster flavor (e.g. FargateCluster vs eks.Cluster)
     * @param scope
     * @param id
     * @param clusterOptions
     * @returns
     */
    protected internalCreateCluster(scope: Construct, id: string, clusterOptions: any): eks.Cluster | eksv1.Cluster;
    /**
     * Can be overridden to provide a custom kubectl layer.
     * @param scope
     * @param version
     * @returns
     */
    protected getKubectlLayer(scope: Construct, version: eks.KubernetesVersion): ILayerVersion | undefined;
    /**
     * Adds an autoscaling group to the cluster.
     * @param cluster
     * @param nodeGroup
     * @returns
     */
    addAutoScalingGroup(cluster: eks.Cluster, nodeGroup: AutoscalingNodeGroup): autoscaling.AutoScalingGroup;
    /**
     * Adds a fargate profile to the cluster
     */
    addFargateProfile(cluster: eks.Cluster, name: string, profileOptions: eks.FargateProfileOptions): eks.FargateProfile;
    /**
     * Add a node pool to the cluster
     */
    addNodePool(cluster: eks.Cluster, name: string, pool: NodePoolV1Spec): eks.KubernetesManifest;
    /**
     * Adds a managed node group to the cluster.
     * @param cluster
     * @param nodeGroup
     * @returns
     */
    addManagedNodeGroup(cluster: eks.Cluster, nodeGroup: ManagedNodeGroup): eks.Nodegroup;
    private validateInput;
}
