"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddOnNameOrId = getAddOnNameOrId;
exports.isOrderedAddOn = isOrderedAddOn;
exports.dependable = dependable;
exports.conflictsWith = conflictsWith;
exports.conflictsWithAutoMode = conflictsWithAutoMode;
const assert = require("assert");
require("reflect-metadata");
const semver = require("semver");
const log_utils_1 = require("./log-utils");
/**
 * Returns AddOn Id if defined else returns the class name
 * @param addOn
 * @returns string
 */
function getAddOnNameOrId(addOn) {
    var _a;
    return (_a = addOn.id) !== null && _a !== void 0 ? _a : addOn.constructor.name;
}
function isOrderedAddOn(addOn) {
    var _a, _b;
    return (_b = (_a = Reflect.getMetadata("ordered", addOn.constructor)) !== null && _a !== void 0 ? _a : Reflect.getMetadata("ordered", addOn)) !== null && _b !== void 0 ? _b : false;
}
/**
 * Decorator function that accepts a list of AddOns and
 * ensures addons are scheduled to be added as well as
 * add them as dependencies
 * @param addOns
 * @returns
 */
function dependable(...addOns) {
    return function (target, key, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            const dependencies = Array();
            const clusterInfo = args[0];
            const stack = clusterInfo.cluster.stack.stackName;
            addOns.forEach((addOn) => {
                var _a, _b;
                if (clusterInfo.autoMode && isAutoModeAddon(addOn)) {
                    return;
                }
                const dep = clusterInfo.getScheduledAddOn(addOn);
                let targetString = (_b = (_a = target === null || target === void 0 ? void 0 : target.constructor) === null || _a === void 0 ? void 0 : _a.toString().split("\n")[0]) !== null && _b !== void 0 ? _b : "unknown";
                assert(dep, `Missing a dependency for ${addOn} for ${stack} and target ${targetString}`);
                dependencies.push(dep);
            });
            const result = originalMethod.apply(this, args);
            Promise.all(dependencies.values()).then((constructs) => {
                constructs.forEach((construct) => {
                    result.then((resource) => {
                        resource.node.addDependency(construct);
                    });
                });
            }).catch(err => { throw new Error(err); });
            return result;
        };
        return descriptor;
    };
}
/**
 * Decorator function that accepts a list of AddOns and
 * throws error if those addons are scheduled to be added as well
 * As they should not be deployed with
 * @param addOns
 * @returns
 */
function conflictsWith(...addOns) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (target, key, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            // const dependencies: (Promise<Construct> | undefined)[] = [];
            const clusterInfo = args[0];
            const stack = clusterInfo.cluster.stack.stackName;
            addOns.forEach((addOn) => {
                const dep = clusterInfo.getScheduledAddOn(addOn);
                if (dep) {
                    throw new Error(`Deploying ${stack} failed due to conflicting add-on: ${addOn}.`);
                }
            });
            return originalMethod.apply(this, args);
        };
        return descriptor;
    };
}
function compareEksVersions(version1, version2) {
    // Extract semver and build number from both versions
    const [semver1, build1] = parseEksVersion(version1);
    const [semver2, build2] = parseEksVersion(version2);
    // Compare semver parts first
    const semverCompare = semver.compare(semver1, semver2);
    if (semverCompare !== 0)
        return semverCompare;
    // If semver parts are equal, compare build numbers
    return build1 - build2;
}
// Helper function to parse EKS version
function parseEksVersion(version) {
    const match = version.match(/^v?(\d+\.\d+\.\d+)(?:-eksbuild\.(\d+))?$/);
    if (!match) {
        throw new Error(`Invalid EKS version format: ${version}`);
    }
    return [match[1], parseInt(match[2] || '0', 10)];
}
function conflictsWithAutoMode(minExpectedVersion) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (target, key, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            const clusterInfo = args[0];
            const stack = clusterInfo.cluster.stack.stackName;
            if (!clusterInfo.autoMode) {
                return originalMethod.apply(this, args);
            }
            if (minExpectedVersion === "fail") {
                throw new Error(`Deploying ${stack} failed. This add-on is already available on the cluster with EKS Auto Mode.`);
            }
            else if (minExpectedVersion == null) {
                log_utils_1.logger.warn(`This add-on is already available on the cluster with EKS Auto Mode.`);
                return originalMethod.apply(this, args);
            }
            else if (compareEksVersions(this.version, minExpectedVersion) >= 0) { // what to do if other nodegroups attached too?
                log_utils_1.logger.warn(`This add-on is already available on the cluster with EKS Auto Mode.`);
                return originalMethod.apply(this, args);
            }
            else {
                throw new Error(`Deploying ${stack} failed. This add-on is already available on the cluster with EKS Auto Mode.  If you would like to install this addon alongside automode, please upgrade to version ${minExpectedVersion}`);
            }
        };
        return descriptor;
    };
}
/**
 * Checks if the passed addon is part of auto mode and deployed by the EKS CP.
 * @param addOn addOn name to check
 * @returns true if it is one of the addOns that is managed by the EKS in Auto Mode
 */
function isAutoModeAddon(addOn) {
    const automodeAddons = [
        "EbsCsiDriverAddOn",
        "AwsLoadBalancerControllerAddOn",
        "VpcCniAddOn",
        "CoreDnsAddOn",
        "KubeProxyAddOn",
    ];
    return automodeAddons.includes(addOn);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkb24tdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvdXRpbHMvYWRkb24tdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFZQSw0Q0FFQztBQUVELHdDQUVDO0FBU0QsZ0NBcUNDO0FBU0Qsc0NBc0JDO0FBeUJELHNEQTRCQztBQXBKRCxpQ0FBaUM7QUFFakMsNEJBQTBCO0FBRTFCLGlDQUFpQztBQUNqQywyQ0FBcUM7QUFFckM7Ozs7R0FJRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLEtBQW1COztJQUNsRCxPQUFPLE1BQUEsS0FBSyxDQUFDLEVBQUUsbUNBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7QUFDNUMsQ0FBQztBQUVELFNBQWdCLGNBQWMsQ0FBQyxLQUFtQjs7SUFDOUMsT0FBTyxNQUFBLE1BQUEsT0FBTyxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLFdBQVcsQ0FBQyxtQ0FBSSxPQUFPLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsbUNBQUksS0FBSyxDQUFDO0FBQy9HLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixVQUFVLENBQUMsR0FBRyxNQUFnQjtJQUU1QyxPQUFPLFVBQVUsTUFBVyxFQUFFLEdBQW9CLEVBQUUsVUFBOEI7UUFDaEYsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQztRQUV4QyxVQUFVLENBQUMsS0FBSyxHQUFHLFVBQVUsR0FBRyxJQUFXO1lBQ3pDLE1BQU0sWUFBWSxHQUFHLEtBQUssRUFBc0IsQ0FBQztZQUNqRCxNQUFNLFdBQVcsR0FBZ0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztZQUVsRCxNQUFNLENBQUMsT0FBTyxDQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7O2dCQUN4QixJ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LGFBQWEsS0FBSyw4RUFBOEUsQ0FBQyxDQUFDO1lBQ3BILENBQUM7aUJBQ0ksSUFBSSxrQkFBa0IsSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFDcEMsa0JBQU0sQ0FBQyxJQUFJLENBQUMscUVBQXFFLENBQUMsQ0FBQztnQkFDbkYsT0FBTyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMxQyxDQUFDO2lCQUNJLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsRUFBQyxDQUFDLENBQUMsK0NBQStDO2dCQUNsSCxrQkFBTSxDQUFDLElBQUksQ0FBQyxxRUFBcUUsQ0FBQyxDQUFDO2dCQUNuRixPQUFPLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzFDLENBQUM7aUJBQU0sQ0FBQztnQkFDTixNQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsS0FBSyx1S0FBdUssa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO1lBQ2pPLENBQUM7UUFDSCxDQUFDLENBQUM7UUFFRSxPQUFPLFVBQVUsQ0FBQztJQUN4QixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsZUFBZSxDQUFDLEtBQWE7SUFDcEMsTUFBTSxjQUFjLEdBQUc7UUFDckIsbUJBQW1CO1FBQ25CLGdDQUFnQztRQUNoQyxhQUFhO1FBQ2IsY0FBYztRQUNkLGdCQUFnQjtLQUNqQixDQUFDO0lBQ0YsT0FBTyxjQUFjLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCBcInJlZmxlY3QtbWV0YWRhdGFcIjtcbmltcG9ydCB7IENsdXN0ZXJBZGRPbiwgQ2x1c3RlckluZm8gfSBmcm9tICcuLi9zcGknO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gXCJzZW12ZXJcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuL2xvZy11dGlsc1wiO1xuXG4vKipcbiAqIFJldHVybnMgQWRkT24gSWQgaWYgZGVmaW5lZCBlbHNlIHJldHVybnMgdGhlIGNsYXNzIG5hbWVcbiAqIEBwYXJhbSBhZGRPblxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRPbk5hbWVPcklkKGFkZE9uOiBDbHVzdGVyQWRkT24pOiBzdHJpbmcge1xuICByZXR1cm4gYWRkT24uaWQgPz8gYWRkT24uY29uc3RydWN0b3IubmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3JkZXJlZEFkZE9uKGFkZE9uOiBDbHVzdGVyQWRkT24pIDogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJvcmRlcmVkXCIsIGFkZE9uLmNvbnN0cnVjdG9yKSA/PyBSZWZsZWN0LmdldE1ldGFkYXRhKFwib3JkZXJlZFwiLCBhZGRPbikgPz8gZmFsc2U7XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIGxpc3Qgb2YgQWRkT25zIGFuZFxuICogZW5zdXJlcyBhZGRvbnMgYXJlIHNjaGVkdWxlZCB0byBiZSBhZGRlZCBhcyB3ZWxsIGFzXG4gKiBhZGQgdGhlbSBhcyBkZXBlbmRlbmNpZXNcbiAqIEBwYXJhbSBhZGRPbnMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcGVuZGFibGUoLi4uYWRkT25zOiBzdHJpbmdbXSkge1xuICBcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwga2V5OiBzdHJpbmcgfCBzeW1ib2wsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiggLi4uYXJnczogYW55W10pIHtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IEFycmF5PFByb21pc2U8Q29uc3RydWN0Pj4oKTtcbiAgICAgIGNvbnN0IGNsdXN0ZXJJbmZvOiBDbHVzdGVySW5mbyA9IGFyZ3NbMF07XG4gICAgICBjb25zdCBzdGFjayA9IGNsdXN0ZXJJbmZvLmNsdXN0ZXIuc3RhY2suc3RhY2tOYW1lO1xuXG4gICAgICBhZGRPbnMuZm9yRWFjaCggKGFkZE9uKSA9PiB7XG4gICAgICAgIGlmKGNsdXN0ZXJJbmZvLmF1dG9Nb2RlICYmIGlzQXV0b01vZGVBZGRvbihhZGRPbikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwID0gY2x1c3RlckluZm8uZ2V0U2NoZWR1bGVkQWRkT24oYWRkT24pO1xuICAgICAgIFxuICAgICAgICBsZXQgdGFyZ2V0U3RyaW5nID0gdGFyZ2V0Py5jb25zdHJ1Y3Rvcj8udG9TdHJpbmcoKS5zcGxpdChcIlxcblwiKVswXSA/PyBcInVua25vd25cIjtcblxuICAgICAgICBhc3NlcnQoZGVwLCBgTWlzc2luZyBhIGRlcGVuZGVuY3kgZm9yICR7YWRkT259IGZvciAke3N0YWNrfSBhbmQgdGFyZ2V0ICR7dGFyZ2V0U3RyaW5nfWApO1xuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChkZXAhKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQ6IFByb21pc2U8Q29uc3RydWN0PiA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICBQcm9taXNlLmFsbChkZXBlbmRlbmNpZXMudmFsdWVzKCkpLnRoZW4oKGNvbnN0cnVjdHMpID0+IHtcbiAgICAgICAgY29uc3RydWN0cy5mb3JFYWNoKChjb25zdHJ1Y3QpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKChyZXNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICByZXNvdXJjZS5ub2RlLmFkZERlcGVuZGVuY3koY29uc3RydWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7IHRocm93IG5ldyBFcnJvcihlcnIpOyB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIGxpc3Qgb2YgQWRkT25zIGFuZFxuICogdGhyb3dzIGVycm9yIGlmIHRob3NlIGFkZG9ucyBhcmUgc2NoZWR1bGVkIHRvIGJlIGFkZGVkIGFzIHdlbGxcbiAqIEFzIHRoZXkgc2hvdWxkIG5vdCBiZSBkZXBsb3llZCB3aXRoXG4gKiBAcGFyYW0gYWRkT25zIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25mbGljdHNXaXRoKC4uLmFkZE9uczogc3RyaW5nW10pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IE9iamVjdCwga2V5OiBzdHJpbmcgfCBzeW1ib2wsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiggLi4uYXJnczogYW55W10pIHtcbiAgICAgIC8vIGNvbnN0IGRlcGVuZGVuY2llczogKFByb21pc2U8Q29uc3RydWN0PiB8IHVuZGVmaW5lZClbXSA9IFtdO1xuICAgICAgY29uc3QgY2x1c3RlckluZm86IENsdXN0ZXJJbmZvID0gYXJnc1swXTtcbiAgICAgIGNvbnN0IHN0YWNrID0gY2x1c3RlckluZm8uY2x1c3Rlci5zdGFjay5zdGFja05hbWU7XG5cbiAgICAgIGFkZE9ucy5mb3JFYWNoKCAoYWRkT24pID0+IHtcbiAgICAgICAgY29uc3QgZGVwID0gY2x1c3RlckluZm8uZ2V0U2NoZWR1bGVkQWRkT24oYWRkT24pO1xuICAgICAgICBpZiAoZGVwKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlcGxveWluZyAke3N0YWNrfSBmYWlsZWQgZHVlIHRvIGNvbmZsaWN0aW5nIGFkZC1vbjogJHthZGRPbn0uYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlRWtzVmVyc2lvbnModmVyc2lvbjE6IHN0cmluZywgdmVyc2lvbjI6IHN0cmluZyk6IG51bWJlciB7XG4gIC8vIEV4dHJhY3Qgc2VtdmVyIGFuZCBidWlsZCBudW1iZXIgZnJvbSBib3RoIHZlcnNpb25zXG4gIGNvbnN0IFtzZW12ZXIxLCBidWlsZDFdID0gcGFyc2VFa3NWZXJzaW9uKHZlcnNpb24xKTtcbiAgY29uc3QgW3NlbXZlcjIsIGJ1aWxkMl0gPSBwYXJzZUVrc1ZlcnNpb24odmVyc2lvbjIpO1xuXG4gIC8vIENvbXBhcmUgc2VtdmVyIHBhcnRzIGZpcnN0XG4gIGNvbnN0IHNlbXZlckNvbXBhcmUgPSBzZW12ZXIuY29tcGFyZShzZW12ZXIxLCBzZW12ZXIyKTtcbiAgaWYgKHNlbXZlckNvbXBhcmUgIT09IDApIHJldHVybiBzZW12ZXJDb21wYXJlO1xuXG4gIC8vIElmIHNlbXZlciBwYXJ0cyBhcmUgZXF1YWwsIGNvbXBhcmUgYnVpbGQgbnVtYmVyc1xuICByZXR1cm4gYnVpbGQxIC0gYnVpbGQyO1xufVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIEVLUyB2ZXJzaW9uXG5mdW5jdGlvbiBwYXJzZUVrc1ZlcnNpb24odmVyc2lvbjogc3RyaW5nKTogW3N0cmluZywgbnVtYmVyXSB7XG4gIGNvbnN0IG1hdGNoID0gdmVyc2lvbi5tYXRjaCgvXnY/KFxcZCtcXC5cXGQrXFwuXFxkKykoPzotZWtzYnVpbGRcXC4oXFxkKykpPyQvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFS1MgdmVyc2lvbiBmb3JtYXQ6ICR7dmVyc2lvbn1gKTtcbiAgfVxuICByZXR1cm4gW21hdGNoWzFdLCBwYXJzZUludChtYXRjaFsyXSB8fCAnMCcsIDEwKV07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZsaWN0c1dpdGhBdXRvTW9kZShtaW5FeHBlY3RlZFZlcnNpb246IHN0cmluZyB8IG51bGwpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogT2JqZWN0LCBrZXk6IHN0cmluZyB8IHN5bWJvbCwgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uKHRoaXM6IGFueSwgLi4uYXJnczogYW55W10pIHtcbiAgICAgIGNvbnN0IGNsdXN0ZXJJbmZvOiBDbHVzdGVySW5mbyA9IGFyZ3NbMF07XG4gICAgICBjb25zdCBzdGFjayA9IGNsdXN0ZXJJbmZvLmNsdXN0ZXIuc3RhY2suc3RhY2tOYW1lO1xuICAgICAgaWYgKCFjbHVzdGVySW5mby5hdXRvTW9kZSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICBpZiAobWluRXhwZWN0ZWRWZXJzaW9uID09PSBcImZhaWxcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlcGxveWluZyAke3N0YWNrfSBmYWlsZWQuIFRoaXMgYWRkLW9uIGlzIGFscmVhZHkgYXZhaWxhYmxlIG9uIHRoZSBjbHVzdGVyIHdpdGggRUtTIEF1dG8gTW9kZS5gKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1pbkV4cGVjdGVkVmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBUaGlzIGFkZC1vbiBpcyBhbHJlYWR5IGF2YWlsYWJsZSBvbiB0aGUgY2x1c3RlciB3aXRoIEVLUyBBdXRvIE1vZGUuYCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbXBhcmVFa3NWZXJzaW9ucyh0aGlzLnZlcnNpb24sIG1pbkV4cGVjdGVkVmVyc2lvbikgPj0gMCl7IC8vIHdoYXQgdG8gZG8gaWYgb3RoZXIgbm9kZWdyb3VwcyBhdHRhY2hlZCB0b28/XG4gICAgICAgIGxvZ2dlci53YXJuKGBUaGlzIGFkZC1vbiBpcyBhbHJlYWR5IGF2YWlsYWJsZSBvbiB0aGUgY2x1c3RlciB3aXRoIEVLUyBBdXRvIE1vZGUuYCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVwbG95aW5nICR7c3RhY2t9IGZhaWxlZC4gVGhpcyBhZGQtb24gaXMgYWxyZWFkeSBhdmFpbGFibGUgb24gdGhlIGNsdXN0ZXIgd2l0aCBFS1MgQXV0byBNb2RlLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gaW5zdGFsbCB0aGlzIGFkZG9uIGFsb25nc2lkZSBhdXRvbW9kZSwgcGxlYXNlIHVwZ3JhZGUgdG8gdmVyc2lvbiAke21pbkV4cGVjdGVkVmVyc2lvbn1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIGFkZG9uIGlzIHBhcnQgb2YgYXV0byBtb2RlIGFuZCBkZXBsb3llZCBieSB0aGUgRUtTIENQLiBcbiAqIEBwYXJhbSBhZGRPbiBhZGRPbiBuYW1lIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIGl0IGlzIG9uZSBvZiB0aGUgYWRkT25zIHRoYXQgaXMgbWFuYWdlZCBieSB0aGUgRUtTIGluIEF1dG8gTW9kZVxuICovXG5mdW5jdGlvbiBpc0F1dG9Nb2RlQWRkb24oYWRkT246IHN0cmluZykgOiBib29sZWFuIHtcbiAgY29uc3QgYXV0b21vZGVBZGRvbnMgPSBbXG4gICAgXCJFYnNDc2lEcml2ZXJBZGRPblwiLFxuICAgIFwiQXdzTG9hZEJhbGFuY2VyQ29udHJvbGxlckFkZE9uXCIsXG4gICAgXCJWcGNDbmlBZGRPblwiLFxuICAgIFwiQ29yZURuc0FkZE9uXCIsXG4gICAgXCJLdWJlUHJveHlBZGRPblwiLFxuICBdO1xuICByZXR1cm4gYXV0b21vZGVBZGRvbnMuaW5jbHVkZXMoYWRkT24pO1xufVxuXG4iXX0=