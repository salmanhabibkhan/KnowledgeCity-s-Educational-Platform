"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionCheckTTL = void 0;
exports.displayVersion = displayVersion;
exports.isDeveloperBuild = isDeveloperBuild;
exports.versionNumber = versionNumber;
exports.getVersionMessages = getVersionMessages;
exports.displayVersionMessage = displayVersionMessage;
/* c8 ignore start */
const path = require("path");
const chalk = require("chalk");
const fs = require("fs-extra");
const semver = require("semver");
const api_1 = require("../../../@aws-cdk/tmp-toolkit-helpers/src/api");
const logging_1 = require("../logging");
const util_1 = require("../util");
const root_dir_1 = require("./root-dir");
const console_formatters_1 = require("./util/console-formatters");
const npm_1 = require("./util/npm");
const ONE_DAY_IN_SECONDS = 1 * 24 * 60 * 60;
const UPGRADE_DOCUMENTATION_LINKS = {
    1: 'https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html',
};
function displayVersion() {
    return `${versionNumber()} (build ${commit()})`;
}
function isDeveloperBuild() {
    return versionNumber() === '0.0.0';
}
function versionNumber() {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    return require(path.join((0, root_dir_1.cliRootDir)(), 'package.json')).version.replace(/\+[0-9a-f]+$/, '');
}
function commit() {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    return require(path.join((0, root_dir_1.cliRootDir)(), 'build-info.json')).commit;
}
class VersionCheckTTL {
    static timestampFilePath() {
        // Using the same path from account-cache.ts
        return path.join((0, util_1.cdkCacheDir)(), 'repo-version-ttl');
    }
    constructor(file, ttlSecs) {
        this.file = file || VersionCheckTTL.timestampFilePath();
        try {
            fs.mkdirsSync(path.dirname(this.file));
            fs.accessSync(path.dirname(this.file), fs.constants.W_OK);
        }
        catch {
            throw new api_1.ToolkitError(`Directory (${path.dirname(this.file)}) is not writable.`);
        }
        this.ttlSecs = ttlSecs || ONE_DAY_IN_SECONDS;
    }
    async hasExpired() {
        try {
            const lastCheckTime = (await fs.stat(this.file)).mtimeMs;
            const today = new Date().getTime();
            if ((today - lastCheckTime) / 1000 > this.ttlSecs) { // convert ms to sec
                return true;
            }
            return false;
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return true;
            }
            else {
                throw err;
            }
        }
    }
    async update(latestVersion) {
        if (!latestVersion) {
            latestVersion = '';
        }
        await fs.writeFile(this.file, latestVersion);
    }
}
exports.VersionCheckTTL = VersionCheckTTL;
// Export for unit testing only.
// Don't use directly, use displayVersionMessage() instead.
async function getVersionMessages(currentVersion, cacheFile) {
    if (!(await cacheFile.hasExpired())) {
        return [];
    }
    const packageInfo = await (0, npm_1.execNpmView)(currentVersion);
    const latestVersion = packageInfo.latestVersion;
    await cacheFile.update(JSON.stringify(packageInfo));
    // If the latest version is the same as the current version, there is no need to display a message
    if (semver.eq(latestVersion, currentVersion)) {
        return [];
    }
    const versionMessage = [
        packageInfo.deprecated ? `${chalk.red(packageInfo.deprecated)}` : undefined,
        `Newer version of CDK is available [${chalk.green(latestVersion)}]`,
        getMajorVersionUpgradeMessage(currentVersion),
        'Upgrade recommended (npm install -g aws-cdk)',
    ].filter(Boolean);
    return versionMessage;
}
function getMajorVersionUpgradeMessage(currentVersion) {
    const currentMajorVersion = semver.major(currentVersion);
    if (UPGRADE_DOCUMENTATION_LINKS[currentMajorVersion]) {
        return `Information about upgrading from version ${currentMajorVersion}.x to version ${currentMajorVersion + 1}.x is available here: ${UPGRADE_DOCUMENTATION_LINKS[currentMajorVersion]}`;
    }
}
async function displayVersionMessage(currentVersion = versionNumber(), versionCheckCache) {
    if (!process.stdout.isTTY || process.env.CDK_DISABLE_VERSION_CHECK) {
        return;
    }
    try {
        const versionMessages = await getVersionMessages(currentVersion, versionCheckCache ?? new VersionCheckTTL());
        (0, console_formatters_1.formatAsBanner)(versionMessages).forEach(e => (0, logging_1.info)(e));
    }
    catch (err) {
        (0, logging_1.debug)(`Could not run version check - ${err.message}`);
    }
}
/* c8 ignore stop */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBa0JBLHdDQUVDO0FBRUQsNENBRUM7QUFFRCxzQ0FHQztBQXlERCxnREFzQkM7QUFTRCxzREFXQztBQWhJRCxxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLHVFQUE2RTtBQUM3RSx3Q0FBeUM7QUFDekMsa0NBQXNDO0FBQ3RDLHlDQUF3QztBQUN4QyxrRUFBMkQ7QUFDM0Qsb0NBQXlDO0FBRXpDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBRTVDLE1BQU0sMkJBQTJCLEdBQTJCO0lBQzFELENBQUMsRUFBRSw0REFBNEQ7Q0FDaEUsQ0FBQztBQUVGLFNBQWdCLGNBQWM7SUFDNUIsT0FBTyxHQUFHLGFBQWEsRUFBRSxXQUFXLE1BQU0sRUFBRSxHQUFHLENBQUM7QUFDbEQsQ0FBQztBQUVELFNBQWdCLGdCQUFnQjtJQUM5QixPQUFPLGFBQWEsRUFBRSxLQUFLLE9BQU8sQ0FBQztBQUNyQyxDQUFDO0FBRUQsU0FBZ0IsYUFBYTtJQUMzQixpRUFBaUU7SUFDakUsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFBLHFCQUFVLEdBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzlGLENBQUM7QUFFRCxTQUFTLE1BQU07SUFDYixpRUFBaUU7SUFDakUsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFBLHFCQUFVLEdBQUUsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3BFLENBQUM7QUFFRCxNQUFhLGVBQWU7SUFDbkIsTUFBTSxDQUFDLGlCQUFp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b0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiLyogYzggaWdub3JlIHN0YXJ0ICovXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGknO1xuaW1wb3J0IHsgZGVidWcsIGluZm8gfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IGNka0NhY2hlRGlyIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBjbGlSb290RGlyIH0gZnJvbSAnLi9yb290LWRpcic7XG5pbXBvcnQgeyBmb3JtYXRBc0Jhbm5lciB9IGZyb20gJy4vdXRpbC9jb25zb2xlLWZvcm1hdHRlcnMnO1xuaW1wb3J0IHsgZXhlY05wbVZpZXcgfSBmcm9tICcuL3V0aWwvbnBtJztcblxuY29uc3QgT05FX0RBWV9JTl9TRUNPTkRTID0gMSAqIDI0ICogNjAgKiA2MDtcblxuY29uc3QgVVBHUkFERV9ET0NVTUVOVEFUSU9OX0xJTktTOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAxOiAnaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay92Mi9ndWlkZS9taWdyYXRpbmctdjIuaHRtbCcsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheVZlcnNpb24oKSB7XG4gIHJldHVybiBgJHt2ZXJzaW9uTnVtYmVyKCl9IChidWlsZCAke2NvbW1pdCgpfSlgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZXZlbG9wZXJCdWlsZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHZlcnNpb25OdW1iZXIoKSA9PT0gJzAuMC4wJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcnNpb25OdW1iZXIoKTogc3RyaW5nIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgcmV0dXJuIHJlcXVpcmUocGF0aC5qb2luKGNsaVJvb3REaXIoKSwgJ3BhY2thZ2UuanNvbicpKS52ZXJzaW9uLnJlcGxhY2UoL1xcK1swLTlhLWZdKyQvLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdCgpOiBzdHJpbmcge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICByZXR1cm4gcmVxdWlyZShwYXRoLmpvaW4oY2xpUm9vdERpcigpLCAnYnVpbGQtaW5mby5qc29uJykpLmNvbW1pdDtcbn1cblxuZXhwb3J0IGNsYXNzIFZlcnNpb25DaGVja1RUTCB7XG4gIHB1YmxpYyBzdGF0aWMgdGltZXN0YW1wRmlsZVBhdGgoKTogc3RyaW5nIHtcbiAgICAvLyBVc2luZyB0aGUgc2FtZSBwYXRoIGZyb20gYWNjb3VudC1jYWNoZS50c1xuICAgIHJldHVybiBwYXRoLmpvaW4oY2RrQ2FjaGVEaXIoKSwgJ3JlcG8tdmVyc2lvbi10dGwnKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgZmlsZTogc3RyaW5nO1xuXG4gIC8vIEZpbGUgbW9kaWZ5IHRpbWVzIGFyZSBhY2N1cmF0ZSBvbmx5IHRvIHRoZSBzZWNvbmRcbiAgcHJpdmF0ZSByZWFkb25seSB0dGxTZWNzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZmlsZT86IHN0cmluZywgdHRsU2Vjcz86IG51bWJlcikge1xuICAgIHRoaXMuZmlsZSA9IGZpbGUgfHwgVmVyc2lvbkNoZWNrVFRMLnRpbWVzdGFtcEZpbGVQYXRoKCk7XG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyc1N5bmMocGF0aC5kaXJuYW1lKHRoaXMuZmlsZSkpO1xuICAgICAgZnMuYWNjZXNzU3luYyhwYXRoLmRpcm5hbWUodGhpcy5maWxlKSwgZnMuY29uc3RhbnRzLldfT0spO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgRGlyZWN0b3J5ICgke3BhdGguZGlybmFtZSh0aGlzLmZpbGUpfSkgaXMgbm90IHdyaXRhYmxlLmApO1xuICAgIH1cbiAgICB0aGlzLnR0bFNlY3MgPSB0dGxTZWNzIHx8IE9ORV9EQVlfSU5fU0VDT05EUztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBoYXNFeHBpcmVkKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsYXN0Q2hlY2tUaW1lID0gKGF3YWl0IGZzLnN0YXQodGhpcy5maWxlKSkubXRpbWVNcztcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgIGlmICgodG9kYXkgLSBsYXN0Q2hlY2tUaW1lKSAvIDEwMDAgPiB0aGlzLnR0bFNlY3MpIHsgLy8gY29udmVydCBtcyB0byBzZWNcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHVwZGF0ZShsYXRlc3RWZXJzaW9uPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFsYXRlc3RWZXJzaW9uKSB7XG4gICAgICBsYXRlc3RWZXJzaW9uID0gJyc7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0aGlzLmZpbGUsIGxhdGVzdFZlcnNpb24pO1xuICB9XG59XG5cbi8vIEV4cG9ydCBmb3IgdW5pdCB0ZXN0aW5nIG9ubHkuXG4vLyBEb24ndCB1c2UgZGlyZWN0bHksIHVzZSBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKSBpbnN0ZWFkLlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb25NZXNzYWdlcyhjdXJyZW50VmVyc2lvbjogc3RyaW5nLCBjYWNoZUZpbGU6IFZlcnNpb25DaGVja1RUTCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgaWYgKCEoYXdhaXQgY2FjaGVGaWxlLmhhc0V4cGlyZWQoKSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBwYWNrYWdlSW5mbyA9IGF3YWl0IGV4ZWNOcG1WaWV3KGN1cnJlbnRWZXJzaW9uKTtcbiAgY29uc3QgbGF0ZXN0VmVyc2lvbiA9IHBhY2thZ2VJbmZvLmxhdGVzdFZlcnNpb247XG4gIGF3YWl0IGNhY2hlRmlsZS51cGRhdGUoSlNPTi5zdHJpbmdpZnkocGFja2FnZUluZm8pKTtcblxuICAvLyBJZiB0aGUgbGF0ZXN0IHZlcnNpb24gaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdmVyc2lvbiwgdGhlcmUgaXMgbm8gbmVlZCB0byBkaXNwbGF5IGEgbWVzc2FnZVxuICBpZiAoc2VtdmVyLmVxKGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHZlcnNpb25NZXNzYWdlID0gW1xuICAgIHBhY2thZ2VJbmZvLmRlcHJlY2F0ZWQgPyBgJHtjaGFsay5yZWQocGFja2FnZUluZm8uZGVwcmVjYXRlZCBhcyBzdHJpbmcpfWAgOiB1bmRlZmluZWQsXG4gICAgYE5ld2VyIHZlcnNpb24gb2YgQ0RLIGlzIGF2YWlsYWJsZSBbJHtjaGFsay5ncmVlbihsYXRlc3RWZXJzaW9uIGFzIHN0cmluZyl9XWAsXG4gICAgZ2V0TWFqb3JWZXJzaW9uVXBncmFkZU1lc3NhZ2UoY3VycmVudFZlcnNpb24pLFxuICAgICdVcGdyYWRlIHJlY29tbWVuZGVkIChucG0gaW5zdGFsbCAtZyBhd3MtY2RrKScsXG4gIF0uZmlsdGVyKEJvb2xlYW4pIGFzIHN0cmluZ1tdO1xuXG4gIHJldHVybiB2ZXJzaW9uTWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFqb3JWZXJzaW9uVXBncmFkZU1lc3NhZ2UoY3VycmVudFZlcnNpb246IHN0cmluZyk6IHN0cmluZyB8IHZvaWQge1xuICBjb25zdCBjdXJyZW50TWFqb3JWZXJzaW9uID0gc2VtdmVyLm1ham9yKGN1cnJlbnRWZXJzaW9uKTtcbiAgaWYgKFVQR1JBREVfRE9DVU1FTlRBVElPTl9MSU5LU1tjdXJyZW50TWFqb3JWZXJzaW9uXSkge1xuICAgIHJldHVybiBgSW5mb3JtYXRpb24gYWJvdXQgdXBncmFkaW5nIGZyb20gdmVyc2lvbiAke2N1cnJlbnRNYWpvclZlcnNpb259LnggdG8gdmVyc2lvbiAke2N1cnJlbnRNYWpvclZlcnNpb24gKyAxfS54IGlzIGF2YWlsYWJsZSBoZXJlOiAke1VQR1JBREVfRE9DVU1FTlRBVElPTl9MSU5LU1tjdXJyZW50TWFqb3JWZXJzaW9uXX1gO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoY3VycmVudFZlcnNpb24gPSB2ZXJzaW9uTnVtYmVyKCksIHZlcnNpb25DaGVja0NhY2hlPzogVmVyc2lvbkNoZWNrVFRMKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghcHJvY2Vzcy5zdGRvdXQuaXNUVFkgfHwgcHJvY2Vzcy5lbnYuQ0RLX0RJU0FCTEVfVkVSU0lPTl9DSEVDSykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdmVyc2lvbk1lc3NhZ2VzID0gYXdhaXQgZ2V0VmVyc2lvbk1lc3NhZ2VzKGN1cnJlbnRWZXJzaW9uLCB2ZXJzaW9uQ2hlY2tDYWNoZSA/PyBuZXcgVmVyc2lvbkNoZWNrVFRMKCkpO1xuICAgIGZvcm1hdEFzQmFubmVyKHZlcnNpb25NZXNzYWdlcykuZm9yRWFjaChlID0+IGluZm8oZSkpO1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGRlYnVnKGBDb3VsZCBub3QgcnVuIHZlcnNpb24gY2hlY2sgLSAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuIl19