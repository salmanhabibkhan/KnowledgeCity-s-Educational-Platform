"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execProgram = execProgram;
exports.createAssembly = createAssembly;
const childProcess = require("child_process");
const os = require("os");
const path = require("path");
const util_1 = require("util");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const semver = require("semver");
const api_1 = require("../api");
const api_private_1 = require("../api-private");
const user_configuration_1 = require("../cli/user-configuration");
const version_1 = require("../cli/version");
const util_2 = require("../util");
/** Invokes the cloud executable and returns JSON output */
async function execProgram(aws, ioHelper, config) {
    const debugFn = (msg) => ioHelper.notify(api_private_1.IO.DEFAULT_ASSEMBLY_DEBUG.msg(msg));
    const env = await (0, api_1.prepareDefaultEnvironment)(aws, debugFn);
    const context = await (0, api_1.prepareContext)(config.settings, config.context.all, env, debugFn);
    const build = config.settings.get(['build']);
    if (build) {
        await exec(build);
    }
    const app = config.settings.get(['app']);
    if (!app) {
        throw new api_1.ToolkitError(`--app is required either in command-line, in ${user_configuration_1.PROJECT_CONFIG} or in ${user_configuration_1.USER_DEFAULTS}`);
    }
    // bypass "synth" if app points to a cloud assembly
    if (await fs.pathExists(app) && (await fs.stat(app)).isDirectory()) {
        await debugFn('--app points to a cloud assembly, so we bypass synth');
        // Acquire a read lock on this directory
        const lock = await new api_1.RWLock(app).acquireRead();
        return { assembly: createAssembly(app), lock };
    }
    const commandLine = await (0, api_1.guessExecutable)(app, debugFn);
    const outdir = config.settings.get(['output']);
    if (!outdir) {
        throw new api_1.ToolkitError('unexpected: --output is required');
    }
    if (typeof outdir !== 'string') {
        throw new api_1.ToolkitError(`--output takes a string, got ${JSON.stringify(outdir)}`);
    }
    try {
        await fs.mkdirp(outdir);
    }
    catch (error) {
        throw new api_1.ToolkitError(`Could not create output directory ${outdir} (${error.message})`);
    }
    await debugFn(`outdir: ${outdir}`);
    env[cxapi.OUTDIR_ENV] = outdir;
    // Acquire a lock on the output directory
    const writerLock = await new api_1.RWLock(outdir).acquireWrite();
    try {
        // Send version information
        env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
        env[cxapi.CLI_VERSION_ENV] = (0, version_1.versionNumber)();
        await debugFn((0, util_1.format)('env:', env));
        const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
        const [smallContext, overflow] = (0, util_2.splitBySize)(context, (0, api_1.spaceAvailableForContext)(env, envVariableSizeLimit));
        // Store the safe part in the environment variable
        env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
        // If there was any overflow, write it to a temporary file
        let contextOverflowLocation;
        if (Object.keys(overflow ?? {}).length > 0) {
            const contextDir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk-context'));
            contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
            fs.writeJSONSync(contextOverflowLocation, overflow);
            env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
        }
        await exec(commandLine.join(' '));
        const assembly = createAssembly(outdir);
        await contextOverflowCleanup(contextOverflowLocation, assembly, ioHelper);
        return { assembly, lock: await writerLock.convertToReaderLock() };
    }
    catch (e) {
        await writerLock.release();
        throw e;
    }
    async function exec(commandAndArgs) {
        try {
            await new Promise((ok, fail) => {
                // We use a slightly lower-level interface to:
                //
                // - Pass arguments in an array instead of a string, to get around a
                //   number of quoting issues introduced by the intermediate shell layer
                //   (which would be different between Linux and Windows).
                //
                // - Inherit stderr from controlling terminal. We don't use the captured value
                //   anyway, and if the subprocess is printing to it for debugging purposes the
                //   user gets to see it sooner. Plus, capturing doesn't interact nicely with some
                //   processes like Maven.
                const proc = childProcess.spawn(commandAndArgs, {
                    stdio: ['ignore', 'inherit', 'inherit'],
                    detached: false,
                    shell: true,
                    env: {
                        ...process.env,
                        ...env,
                    },
                });
                proc.on('error', fail);
                proc.on('exit', code => {
                    if (code === 0) {
                        return ok();
                    }
                    else {
                        return fail(new api_1.ToolkitError(`Subprocess exited with error ${code}`));
                    }
                });
            });
        }
        catch (e) {
            await debugFn(`failed command: ${commandAndArgs}`);
            throw e;
        }
    }
}
/**
 * Creates an assembly with error handling
 */
function createAssembly(appDir) {
    try {
        return new cxapi.CloudAssembly(appDir, {
            // We sort as we deploy
            topoSort: false,
        });
    }
    catch (error) {
        if (error.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            throw new api_1.ToolkitError(`This CDK CLI is not compatible with the CDK library used by your application. Please upgrade the CLI to the latest version.\n(${error.message})`);
        }
        throw error;
    }
}
async function contextOverflowCleanup(location, assembly, ioHelper) {
    if (location) {
        fs.removeSync(path.dirname(location));
        const tree = await (0, api_1.loadTree)(assembly, (msg) => ioHelper.notify(api_private_1.IO.DEFAULT_ASSEMBLY_TRACE.msg(msg)));
        const frameworkDoesNotSupportContextOverflow = (0, api_1.some)(tree, node => {
            const fqn = node.constructInfo?.fqn;
            const version = node.constructInfo?.version;
            return (fqn === 'aws-cdk-lib.App' && version != null && semver.lte(version, '2.38.0'))
                || fqn === '@aws-cdk/core.App'; // v1
        });
        // We're dealing with an old version of the framework here. It is unaware of the temporary
        // file, which means that it will ignore the context overflow.
        if (frameworkDoesNotSupportContextOverflow) {
            await ioHelper.notify(api_private_1.IO.DEFAULT_ASSEMBLY_WARN.msg('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.'));
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4ZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFzQkEsa0NBc0hDO0FBS0Qsd0NBY0M7QUEvSkQsOENBQThDO0FBQzlDLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsK0JBQThCO0FBQzlCLDJEQUEyRDtBQUMzRCx5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLGlDQUFpQztBQUVqQyxnQ0FBb0o7QUFDcEosZ0RBQW1EO0FBRW5ELGtFQUEwRTtBQUMxRSw0Q0FBK0M7QUFDL0Msa0NBQXNDO0FBT3RDLDJEQUEyRDtBQUNwRCxLQUFLLFVBQVUsV0FBVyxDQUFDLEdBQWdCLEVBQUUsUUFBa0IsRUFBRSxNQUFxQjtJQUMzRixNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxnQkFBRSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3JGLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBQSwrQkFBeUIsRUFBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDMUQsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFBLG9CQUFjLEVBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFeEYsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzdDLElBQUksS0FBSyxFQUFFLENBQUM7UUFDVixNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLElBQUksQ0FBQyxHQUFH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O1FBQzVLLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkUHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICd1dGlsJztcbmltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgdHlwZSB7IFNka1Byb3ZpZGVyLCBJUmVhZExvY2sgfSBmcm9tICcuLi9hcGknO1xuaW1wb3J0IHsgUldMb2NrLCBUb29sa2l0RXJyb3IsIGd1ZXNzRXhlY3V0YWJsZSwgbG9hZFRyZWUsIHByZXBhcmVDb250ZXh0LCBwcmVwYXJlRGVmYXVsdEVudmlyb25tZW50LCBzb21lLCBzcGFjZUF2YWlsYWJsZUZvckNvbnRleHQgfSBmcm9tICcuLi9hcGknO1xuaW1wb3J0IHsgSU8sIHR5cGUgSW9IZWxwZXIgfSBmcm9tICcuLi9hcGktcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9jbGkvdXNlci1jb25maWd1cmF0aW9uJztcbmltcG9ydCB7IFBST0pFQ1RfQ09ORklHLCBVU0VSX0RFRkFVTFRTIH0gZnJvbSAnLi4vY2xpL3VzZXItY29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi4vY2xpL3ZlcnNpb24nO1xuaW1wb3J0IHsgc3BsaXRCeVNpemUgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBFeGVjUHJvZ3JhbVJlc3VsdCB7XG4gIHJlYWRvbmx5IGFzc2VtYmx5OiBjeGFwaS5DbG91ZEFzc2VtYmx5O1xuICByZWFkb25seSBsb2NrOiBJUmVhZExvY2s7XG59XG5cbi8qKiBJbnZva2VzIHRoZSBjbG91ZCBleGVjdXRhYmxlIGFuZCByZXR1cm5zIEpTT04gb3V0cHV0ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY1Byb2dyYW0oYXdzOiBTZGtQcm92aWRlciwgaW9IZWxwZXI6IElvSGVscGVyLCBjb25maWc6IENvbmZpZ3VyYXRpb24pOiBQcm9taXNlPEV4ZWNQcm9ncmFtUmVzdWx0PiB7XG4gIGNvbnN0IGRlYnVnRm4gPSAobXNnOiBzdHJpbmcpID0+IGlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX0FTU0VNQkxZX0RFQlVHLm1zZyhtc2cpKTtcbiAgY29uc3QgZW52ID0gYXdhaXQgcHJlcGFyZURlZmF1bHRFbnZpcm9ubWVudChhd3MsIGRlYnVnRm4pO1xuICBjb25zdCBjb250ZXh0ID0gYXdhaXQgcHJlcGFyZUNvbnRleHQoY29uZmlnLnNldHRpbmdzLCBjb25maWcuY29udGV4dC5hbGwsIGVudiwgZGVidWdGbik7XG5cbiAgY29uc3QgYnVpbGQgPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsnYnVpbGQnXSk7XG4gIGlmIChidWlsZCkge1xuICAgIGF3YWl0IGV4ZWMoYnVpbGQpO1xuICB9XG5cbiAgY29uc3QgYXBwID0gY29uZmlnLnNldHRpbmdzLmdldChbJ2FwcCddKTtcbiAgaWYgKCFhcHApIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAtLWFwcCBpcyByZXF1aXJlZCBlaXRoZXIgaW4gY29tbWFuZC1saW5lLCBpbiAke1BST0pFQ1RfQ09ORklHfSBvciBpbiAke1VTRVJfREVGQVVMVFN9YCk7XG4gIH1cblxuICAvLyBieXBhc3MgXCJzeW50aFwiIGlmIGFwcCBwb2ludHMgdG8gYSBjbG91ZCBhc3NlbWJseVxuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhhcHApICYmIChhd2FpdCBmcy5zdGF0KGFwcCkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBhd2FpdCBkZWJ1Z0ZuKCctLWFwcCBwb2ludHMgdG8gYSBjbG91ZCBhc3NlbWJseSwgc28gd2UgYnlwYXNzIHN5bnRoJyk7XG5cbiAgICAvLyBBY3F1aXJlIGEgcmVhZCBsb2NrIG9uIHRoaXMgZGlyZWN0b3J5XG4gICAgY29uc3QgbG9jayA9IGF3YWl0IG5ldyBSV0xvY2soYXBwKS5hY3F1aXJlUmVhZCgpO1xuXG4gICAgcmV0dXJuIHsgYXNzZW1ibHk6IGNyZWF0ZUFzc2VtYmx5KGFwcCksIGxvY2sgfTtcbiAgfVxuXG4gIGNvbnN0IGNvbW1hbmRMaW5lID0gYXdhaXQgZ3Vlc3NFeGVjdXRhYmxlKGFwcCwgZGVidWdGbik7XG5cbiAgY29uc3Qgb3V0ZGlyID0gY29uZmlnLnNldHRpbmdzLmdldChbJ291dHB1dCddKTtcbiAgaWYgKCFvdXRkaXIpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCd1bmV4cGVjdGVkOiAtLW91dHB1dCBpcyByZXF1aXJlZCcpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0ZGlyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYC0tb3V0cHV0IHRha2VzIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvdXRkaXIpfWApO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMubWtkaXJwKG91dGRpcik7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIG91dHB1dCBkaXJlY3RvcnkgJHtvdXRkaXJ9ICgke2Vycm9yLm1lc3NhZ2V9KWApO1xuICB9XG5cbiAgYXdhaXQgZGVidWdGbihgb3V0ZGlyOiAke291dGRpcn1gKTtcbiAgZW52W2N4YXBpLk9VVERJUl9FTlZdID0gb3V0ZGlyO1xuXG4gIC8vIEFjcXVpcmUgYSBsb2NrIG9uIHRoZSBvdXRwdXQgZGlyZWN0b3J5XG4gIGNvbnN0IHdyaXRlckxvY2sgPSBhd2FpdCBuZXcgUldMb2NrKG91dGRpcikuYWNxdWlyZVdyaXRlKCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBTZW5kIHZlcnNpb24gaW5mb3JtYXRpb25cbiAgICBlbnZbY3hhcGkuQ0xJX0FTTV9WRVJTSU9OX0VOVl0gPSBjeHNjaGVtYS5NYW5pZmVzdC52ZXJzaW9uKCk7XG4gICAgZW52W2N4YXBpLkNMSV9WRVJTSU9OX0VOVl0gPSB2ZXJzaW9uTnVtYmVyKCk7XG5cbiAgICBhd2FpdCBkZWJ1Z0ZuKGZvcm1hdCgnZW52OicsIGVudikpO1xuXG4gICAgY29uc3QgZW52VmFyaWFibGVTaXplTGltaXQgPSBvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInID8gMzI3NjAgOiAxMzEwNzI7XG4gICAgY29uc3QgW3NtYWxsQ29udGV4dCwgb3ZlcmZsb3ddID0gc3BsaXRCeVNpemUoY29udGV4dCwgc3BhY2VBdmFpbGFibGVGb3JDb250ZXh0KGVudiwgZW52VmFyaWFibGVTaXplTGltaXQpKTtcblxuICAgIC8vIFN0b3JlIHRoZSBzYWZlIHBhcnQgaW4gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgZW52W2N4YXBpLkNPTlRFWFRfRU5WXSA9IEpTT04uc3RyaW5naWZ5KHNtYWxsQ29udGV4dCk7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYW55IG92ZXJmbG93LCB3cml0ZSBpdCB0byBhIHRlbXBvcmFyeSBmaWxlXG4gICAgbGV0IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uO1xuICAgIGlmIChPYmplY3Qua2V5cyhvdmVyZmxvdyA/PyB7fSkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY29udGV4dERpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrLWNvbnRleHQnKSk7XG4gICAgICBjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiA9IHBhdGguam9pbihjb250ZXh0RGlyLCAnY29udGV4dC1vdmVyZmxvdy5qc29uJyk7XG4gICAgICBmcy53cml0ZUpTT05TeW5jKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uLCBvdmVyZmxvdyk7XG4gICAgICBlbnZbY3hhcGkuQ09OVEVYVF9PVkVSRkxPV19MT0NBVElPTl9FTlZdID0gY29udGV4dE92ZXJmbG93TG9jYXRpb247XG4gICAgfVxuXG4gICAgYXdhaXQgZXhlYyhjb21tYW5kTGluZS5qb2luKCcgJykpO1xuXG4gICAgY29uc3QgYXNzZW1ibHkgPSBjcmVhdGVBc3NlbWJseShvdXRkaXIpO1xuXG4gICAgYXdhaXQgY29udGV4dE92ZXJmbG93Q2xlYW51cChjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiwgYXNzZW1ibHksIGlvSGVscGVyKTtcblxuICAgIHJldHVybiB7IGFzc2VtYmx5LCBsb2NrOiBhd2FpdCB3cml0ZXJMb2NrLmNvbnZlcnRUb1JlYWRlckxvY2soKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgYXdhaXQgd3JpdGVyTG9jay5yZWxlYXNlKCk7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWMoY29tbWFuZEFuZEFyZ3M6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigob2ssIGZhaWwpID0+IHtcbiAgICAgICAgLy8gV2UgdXNlIGEgc2xpZ2h0bHkgbG93ZXItbGV2ZWwgaW50ZXJmYWNlIHRvOlxuICAgICAgICAvL1xuICAgICAgICAvLyAtIFBhc3MgYXJndW1lbnRzIGluIGFuIGFycmF5IGluc3RlYWQgb2YgYSBzdHJpbmcsIHRvIGdldCBhcm91bmQgYVxuICAgICAgICAvLyAgIG51bWJlciBvZiBxdW90aW5nIGlzc3VlcyBpbnRyb2R1Y2VkIGJ5IHRoZSBpbnRlcm1lZGlhdGUgc2hlbGwgbGF5ZXJcbiAgICAgICAgLy8gICAod2hpY2ggd291bGQgYmUgZGlmZmVyZW50IGJldHdlZW4gTGludXggYW5kIFdpbmRvd3MpLlxuICAgICAgICAvL1xuICAgICAgICAvLyAtIEluaGVyaXQgc3RkZXJyIGZyb20gY29udHJvbGxpbmcgdGVybWluYWwuIFdlIGRvbid0IHVzZSB0aGUgY2FwdHVyZWQgdmFsdWVcbiAgICAgICAgLy8gICBhbnl3YXksIGFuZCBpZiB0aGUgc3VicHJvY2VzcyBpcyBwcmludGluZyB0byBpdCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzIHRoZVxuICAgICAgICAvLyAgIHVzZXIgZ2V0cyB0byBzZWUgaXQgc29vbmVyLiBQbHVzLCBjYXB0dXJpbmcgZG9lc24ndCBpbnRlcmFjdCBuaWNlbHkgd2l0aCBzb21lXG4gICAgICAgIC8vICAgcHJvY2Vzc2VzIGxpa2UgTWF2ZW4uXG4gICAgICAgIGNvbnN0IHByb2MgPSBjaGlsZFByb2Nlc3Muc3Bhd24oY29tbWFuZEFuZEFyZ3MsIHtcbiAgICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAnaW5oZXJpdCcsICdpbmhlcml0J10sXG4gICAgICAgICAgZGV0YWNoZWQ6IGZhbHNlLFxuICAgICAgICAgIHNoZWxsOiB0cnVlLFxuICAgICAgICAgIGVudjoge1xuICAgICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgICAgICAuLi5lbnYsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvYy5vbignZXJyb3InLCBmYWlsKTtcblxuICAgICAgICBwcm9jLm9uKCdleGl0JywgY29kZSA9PiB7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChuZXcgVG9vbGtpdEVycm9yKGBTdWJwcm9jZXNzIGV4aXRlZCB3aXRoIGVycm9yICR7Y29kZX1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgYXdhaXQgZGVidWdGbihgZmFpbGVkIGNvbW1hbmQ6ICR7Y29tbWFuZEFuZEFyZ3N9YCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXNzZW1ibHkgd2l0aCBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXNzZW1ibHkoYXBwRGlyOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHkoYXBwRGlyLCB7XG4gICAgICAvLyBXZSBzb3J0IGFzIHdlIGRlcGxveVxuICAgICAgdG9wb1NvcnQ6IGZhbHNlLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoY3hzY2hlbWEuVkVSU0lPTl9NSVNNQVRDSCkpIHtcbiAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIENMSSB2ZXJzaW9uIGlzIHRvbyBvbGQuXG4gICAgICAvLyB3ZSBpbnN0cnVjdCB0aGUgdXNlciB0byB1cGdyYWRlLlxuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGhpcyBDREsgQ0xJIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIENESyBsaWJyYXJ5IHVzZWQgYnkgeW91ciBhcHBsaWNhdGlvbi4gUGxlYXNlIHVwZ3JhZGUgdGhlIENMSSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uXFxuKCR7ZXJyb3IubWVzc2FnZX0pYCk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnRleHRPdmVyZmxvd0NsZWFudXAoXG4gIGxvY2F0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGFzc2VtYmx5OiBjeGFwaS5DbG91ZEFzc2VtYmx5LFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4pIHtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgZnMucmVtb3ZlU3luYyhwYXRoLmRpcm5hbWUobG9jYXRpb24pKTtcblxuICAgIGNvbnN0IHRyZWUgPSBhd2FpdCBsb2FkVHJlZShhc3NlbWJseSwgKG1zZzogc3RyaW5nKSA9PiBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9BU1NFTUJMWV9UUkFDRS5tc2cobXNnKSkpO1xuICAgIGNvbnN0IGZyYW1ld29ya0RvZXNOb3RTdXBwb3J0Q29udGV4dE92ZXJmbG93ID0gc29tZSh0cmVlLCBub2RlID0+IHtcbiAgICAgIGNvbnN0IGZxbiA9IG5vZGUuY29uc3RydWN0SW5mbz8uZnFuO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IG5vZGUuY29uc3RydWN0SW5mbz8udmVyc2lvbjtcbiAgICAgIHJldHVybiAoZnFuID09PSAnYXdzLWNkay1saWIuQXBwJyAmJiB2ZXJzaW9uICE9IG51bGwgJiYgc2VtdmVyLmx0ZSh2ZXJzaW9uLCAnMi4zOC4wJykpXG4gICAgICAgIHx8IGZxbiA9PT0gJ0Bhd3MtY2RrL2NvcmUuQXBwJzsgLy8gdjFcbiAgICB9KTtcblxuICAgIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBvbGQgdmVyc2lvbiBvZiB0aGUgZnJhbWV3b3JrIGhlcmUuIEl0IGlzIHVuYXdhcmUgb2YgdGhlIHRlbXBvcmFyeVxuICAgIC8vIGZpbGUsIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCBpZ25vcmUgdGhlIGNvbnRleHQgb3ZlcmZsb3cuXG4gICAgaWYgKGZyYW1ld29ya0RvZXNOb3RTdXBwb3J0Q29udGV4dE92ZXJmbG93KSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9BU1NFTUJMWV9XQVJOLm1zZygnUGFydCBvZiB0aGUgY29udGV4dCBjb3VsZCBub3QgYmUgc2VudCB0byB0aGUgYXBwbGljYXRpb24uIFBsZWFzZSB1cGRhdGUgdGhlIEFXUyBDREsgbGlicmFyeSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uJykpO1xuICAgIH1cbiAgfVxufVxuIl19